# 编译原理笔记

By 一二的夏季

[TOC]

## Part 0. Introduction

**任务**

​	编译器的任务是什么? 它将高级语言，变成汇编语言程序（**Assembly program**）。汇编语言程序是一种用于编写和构建计算机指令的低级语言。它基于给定的机器指令集编写，可以被汇编器转换成为机器码。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230605185748940.png" alt="image-20230605185748940" style="zoom:20%;" />

**流程**

​	为了完成上述的任务，编译器常分为三个部分：前端、中端、后端。

- 前端(**front end**)：将代码文本转化为抽象表示（**abstract syntax**），这部分完成lexing和parsing。它需要对语言进行理解，检查语法正确性
- 中端（**middle end**）：将抽象表示变为中间形式（**intermediate form**），这部分完成type checking、analysis、optimizaition。在这个阶段，编译器会尝试使用各种技术来改善程序效率和可读性，比如代码优化、循环展开、函数内联等。
- 后端（**back end**）：负责将中间形式转换成目标机器代码。这个过程需要进行寄存器分配、代码生成、对象文件链接等操作，最终生成可执行文件

​    而在这个流程细分中，有两个概念，即**module**（指每一个功能模块）和**interface**（指前后模块中规定的输入输出）

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230605191232318.png" alt="image-20230605191232318" style="zoom:50%;" />

​	下面来解释其中的含义：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230605191512605.png" alt="image-20230605191512605" style="zoom:50%;" />

**结构：**

​	在我们的编程中，使用的是树形结构，ppt里提出了一些重要的关注点：

- A tree is described by one or more typedef, each corresponding to a symbol in the grammar. Each typedef defines a pointer to a corresponding struct.（关于结构）

- When there is more than one nontrivial(value-carraying) symbol in the right-hand side of a rule(example: the rule CompoundStm), The union has a component that is itself a struct；When there is only one nontrivial symbol in the right-hand side of a rule, The union will have a component that is the value；（关于定义上，右侧的符号决定了使用的定义方法）
- Every class will have a constructor function that initializes all the fields（关于写法上，都需要用初始化函数）

​    另外还有一些命名规则，也是了解即可

- Each module (head file) shall have a prefix unique to that module

  

## Part 1. Lexical Analysis

### 1.1 流程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230605193036873.png" alt="image-20230605193036873" style="zoom:50%;" />

**输入**：字符流；**输出**：抛弃空白符和注释后，生成一系列名字、关键字和标点符号的token流

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230414175150943.png" alt="image-20230414175150943" style="zoom:30%;" />

### 1.2 词法单词 | Lexical Tokens

​	Tokens 是指程序设计语言中具有独立含义的最小词法单位，包含单词（ID）、标点符号（，！；）、操作符（+，+=，?:）、分隔符（{}，[]）等

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230414175326610.png" alt="image-20230414175326610" style="zoom:53%;" />

### 1.3 正则表达式 | Regular Expressions 

定义承接计算理论中的定义，基本保持一致：

- **Symbol** : `a` , 匹配字符串 "a"。

- **Alternation** : `M|N` 可以匹配 `M` 和 `N` 匹配集合的并集，表示‘或’。如 `a|b` 可以匹配字符串 "a" 或 "b"。

- **Concatenation** : `M` 和 `N` 是两个正则表达式，`M·N` 可以匹配 `M` 和 `N` 中各一个字符串的联合。如 `(a|b)·a` 匹配字符串 "aa" 或 "ab"。

- **Epsilon** : `ϵ` 匹配空字符串。如 `(a·b)|ϵ` 代表 language {"", "ab"}。

- **Repetition** : `M` 是一个正则表达式，则 `M` 的 **克林闭包 (Kleene closure)** 为 `M*` ，如 `((a|b)·a)*` 表示无穷集合 {"", "aa", "ba", "aaaa", "baaa", "aaba", "baba", "aaaaaa", ... }。

- **缩写表达规则**：我们有时省略 `·` 和 `ϵ` ，并规定 `*` 优先级高于 `·` 高于 `|` 。还有一些缩写形式：

  - `[abcd]` 表示 `(a|b|c|d)`
  - `[b-gM-Qkr]` 表示 `[bcdefgMNOPQkr]`
  - `M?` 表示 `(M|ϵ)` ，即 `M` 出现 0 次或 1 次
  - `M+` 表示 `(M·M*)` ，即 `M` 出现至少 1 次

  - `.` 表示除换行符外的所有单个字符
  - `"a.+*"` ，引号中的字符串匹配其自身

- **匹配规则**：

  - **Longest Match** : 举例，printf("Hello, world!\n")，采用最长匹配原则，则会将其视为一个函数名，而不是被错误地划分成多个短词汇（如pr、in、tf等），也就是不会看成太小的

  - **Rule Priority** :举例，若有一个if，若先在token中写了if，会匹配到if，如果先写了id，会匹配成一个id，就是写的规则是有顺序的，也就是不会看成太大的

### 1.4 确定有限自动机 | DFA & 非确定有限状态机 | NFA

二者和计算理论保持一致

- DFA和NFA的互相转化+DFA最小化：(https://blog.csdn.net/qq_40294512/article/details/89004777)

  **重要**：NFA转闭包时候要充分

  **重要：**DFA最小化的时候，如果ABC，在a和b都转换一致，当c时，AB转化到一个态，C没有能转换的，那么C要单独化为一态

- 最复杂的NFA画法规则：交并闭包如下（https://blog.csdn.net/weixin_44691608/article/details/110195743)：

  **重要：**闭包有一条跳过线；并是有4个e

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230422133725454.png" alt="image-20230422133725454" style="zoom:50%;" />

  ​	

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230422133808817.png" alt="image-20230422133808817" style="zoom:50%;" />



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230422133825899.png" alt="image-20230422133825899" style="zoom:50%;" />





### 1.5 Lex分析

Lex分为三段，分别如下：

```apl
定义(definations)
%%
规则(rules)
%%
代码(user code)
```

一段示例代码，作业中统计词行数的

首先定义基础变量和特定识别标志，用%%分割

再者进行匹配规则定义

最后是一段标准的代码

```apl
%option noyywrap
%{
	int lineCount = 0, charCount = 0, wordCount = 0, isLastBlank = 1;
%}
wordChar	[0-9a-zA-Z]
otherChar	[^{wordChar}]

%%

\n		lineCount++; charCount++; isLastBlank = 1;
{wordChar}	{
			charCount++;
			if (isLastBlank)
				wordCount++;
			isLastBlank = 0;
		}
{otherChar}	charCount++; isLastBlank = 1;

%%

int main() {
	yylex();
	printf("There are %d chars, %d words and %d lines.\n", charCount, wordCount, lineCount);
	return 0;
}
```

lex相关的**yytext** ：返回子串； **yyleng** ：返回子串长度； **yylval** ：创建相关类型的储值空间；yyin，指向正在解析的文件。默认情况下指向 stdin；yyout，指向输出的位置。默认情况下指向 stdout。

### 1.6 家作分析

**关于regular**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230614200621748.png" alt="image-20230614200621748" style="zoom:50%;" />



```
((b|c) * a (b|c)* a (b|c) * ) * | (b|c)*也就是，对于aa的情况列举所有可能，然后再加上没有aa的情况
```

![image-20230614201034458](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230614201034458.png)

```
a*(b|ba|ca*)* or a*((b|c)*(b|c)+a)*(c+aa+)*)*
```

​	正则表达式：不具备记忆、计数比较、递归的能力

****

​	

## Part2. Parsing

### 2.1 基本概念

#### 2.1.1 推导

**左推导：**每次总是把最左边的非终结符转换

**右推导：**每次总是把最右边的非终结符转换

**ambiguous：**有多个parse tree或者多个最左/最右推导

**结尾符：**放在结尾的符号，出现在S状态（起始状态）的推导式中，比如S'->S $

#### 2.1.2 自顶向下与自底向上

​	自底向上（Bottom-up）语法分析与自顶向下（Top-down）语法分析是编译原理中常用的两种语法分析方法。它们之间的区别在于解析输入的方式和构建语法树的顺序。

​	**自顶向下**分析是自语法根节点开始解析输入，不断向下查找能够匹配输入的产生式。常用的是**LL分析器（Left to Right）**。举例分析：从上到下不断搜索，如果错误就回溯，逐步**把non-termianl转变为terminal**。这个过程正是自左向右不断的去寻找的。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320140626055.png" alt="image-20230320140626055" style="zoom:50%;" />

​	**自底向上**分析是从输入开始发掘语法结构，最终到达根节点，形成语法树。该方法又分为移进-归约分析（Shift-Reduce Parsing）和**LR分析器**。举例分析：自底向上，通过shift和reduce逐个**把terminal转到non-terminal**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320140709222.png" alt="image-20230320140709222" style="zoom:50%;" />

​	总之，相比于自顶向下分析，**自底向上分析更加高效，能够处理更复杂的语言结构**。自顶向下分析从语法的高层结构开始解析，并且从上至下逐渐深入到语法树的叶子节点，而自底向上分析则是从语法树的叶子节点开始，通过不断合并子串最终到达语法树的根节点。



#### 2.1.3 活前缀

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423135057330.png" alt="image-20230423135057330" style="zoom:50%;" />

再看道例题：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423135232606.png" alt="image-20230423135232606" style="zoom:50%;" />



分析：ACD都是可以进行归约的，A是n旁边一个e，可以归约到E；C是E旁边一个e，归约到E’；D是E+旁边一个n，归约到E；而B错误的原因是，不管右边加什么，都无法进行归约了

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423135924838.png" alt="image-20230423135924838" style="zoom:50%;" />

分析：看A‘到(A)(A)的转化中

只有B这个是出现过的，并且可以从(A + )e变成(A)A这样的格式

### 2.2  自顶向下

#### 2.2.1 左递归问题

​	左递归要解决的**问题**是：使得不存在A->Aa(a为任意串)的转化，否则由A->Aa将会无休止变成A->Aaaa

​	左递归要使用的**方法**是：使用新的non-terminal放在右端的第一个

​	左递归解决的**实例**是：把右端的A用新的R来替换

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320141057783.png" alt="image-20230320141057783" style="zoom:50%;" />

#### 2.2.2 LL(1)文法

**案例规则：E -> T+E | T   ,  T -> int | int*T | (E)**

**Step 1：提取左因子**

​	目的：使得右边不存在以相同符号开头的式子，如 E -> T+E | T 中，有两个T

​	做法：引入一个新的符号

​	例子： `E -> TX` , `X -> +E | ϵ` 

​				`T -> intY | (E)` , `Y -> *T | ϵ`。

**Step 2：构造follow与first集**

- **first集**

​     意义：non-terminal能推出的一个terminal，或者能推出完全空

<img src="https://cdn.nlark.com/yuque/__latex/ba888e91e51236a12e137014dee77ca4.svg" alt="img" style="zoom:80%;" />

​	 推导：严格意义推导如下，实际推导动脑（**不会特别复杂**）

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320142942877.png" alt="image-20230320142942877" style="zoom:50%;" />

- **follow集**	

​      意义：能存在于一个non-terminal后面的terminal，是**从S开始**推的

​	  实际运用上，需要follow集是因为：当一个非终结字符可以推出空时候的情况，我们需要知道它后面紧跟的是什么终结符合。比如A->BC，B->ϵ，这个时候A能推出什么就要看follow(B)了

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320143208866.png" alt="image-20230320143208866" style="zoom:50%;" />

​	   推导(**其中5可以一开始就做**)：

```c++
S→…U…算Follow(U)
1.如果存在一个产生式 A→…UP，那么First(P)中除了ε 之外都应该放入Follow(U)中
2.如果存在一个产生式 A→…UP, 且First(P)中包含ε，则Follow(A)中的所有元素都在Follow(U)中   
3.如果存在一个产生式 A→…U,则Follow(A)中的所有元素都在Follow(U)中
4.如果存在一个产生式 A→…U…，那么直接把U后面的..拿出作为元素    
5.将$放入Follow(S)中，其中S是开始符号，$是输入右端的结束标识
```



**step 3：构造推测表**

- **Predictive Table**

​      意义：用来进行LL(1)推测的工具

​	   在第二条规则中，**t不可以是空（题目里经常会出现是$）**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320144640513.png" alt="image-20230320144640513" style="zoom:67%;" />

**快速判断条件：**

一个文法如果满足以下三条：
		1）文法不含左递归 A->Ab是不允许的

2）对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。
			即对于A->α1|α2|…|αn
			要求FIRST（αi）∩FIRST（αj）=Ø （i≠j）

3）对于文法中的每个非终结符A，若存在A->ε，则
			FIRST（A）∩FOLLOW（A）=Ø



### 2.3 自底向上

**关系：LR(0)<SLR(1)<LALR(1)<LR(1)**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230417203542334.png" alt="image-20230417203542334" style="zoom:30%;" />

*如果前边一个文法判断是后边都是*

#### 2.3.1 LR(0)

参考链接：[(60条消息) LR（0）文法分析（通过例题穿插讲解）_lr(0)_夜猫程序猿的博客-CSDN博客](https://blog.csdn.net/weixin_57165154/article/details/124332474)

案例分析：给出文法G[S]为：

（1）S->aAcBe

（2）A->Ab

（3）A->b

（4）B->d

**step 1：构造拓广文法**

​	这一步的做法就是增加一个S’对S的指向即可

（0）S‘->S

（1）S->aAcBe

（2）A->Ab

（3）A->b

（4）B->d

**step 2：构造转移DFA**

​	对应上面的5个状态，构造一个对应的DFA

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320145441364.png" alt="image-20230320145441364" style="zoom:80%;" />

**step 3：根据DFA构表并转移**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320145528354.png" alt="image-20230320145528354" style="zoom:80%;" />

​	解释：先把S全部填上，接着把 **没有后继状态** 的状态那一栏全部填上r

​	解释：对应（2）的转换，状态栈栈顶是2，遇到b，ACTION是S4，4进入状态栈，b进入符号栈。

​	对应（3）的转换，由于栈顶是4遇到b，ACTION是r2（**注意这里b不进入符号栈**），利用第二个式子来规约，A进入符号栈，4状态出栈，**然后栈顶是2，遇到A，GOTO是3，3进入状态栈**。

​	也就是：若要进行一步r，那么是先把**符号栈出栈再推进去新元素**，然后**状态栈出栈，根据这个新元素推进一个新元素**（涉及了两组push and pop操作）

​	若要进行一步S，那么是两个push

​	

​	**判断方法：**

​	看表格内是否有归约-归约和移进-归约冲突，本来表格中应该每个只有一项



#### 2.3.2 SLR(1)

参考链接：[(60条消息) SLR(1)_Mafia.M.A的博客-CSDN博客](https://blog.csdn.net/weixin_45427596/article/details/124017197?ops_request_misc=%7B%22request%5Fid%22%3A%22167929012116800184127589%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167929012116800184127589&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124017197-null-null.142^v74^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=SLR(1)&spm=1018.2226.3001.4187)

案例分析：给出文法G[E]为：
		（1）E → E + T | T
		（2）T → F * | F
		（3）F → (E) | a

**step 1：构造拓广文法**

(0) S’ → E
		(1) E → E + T
		(2) E → T
		(3) T → F*
		(4) T → F
		(5) F → (E)
		(6) F → a

**step 2：构造对应的DFA**

​	这里的转换DFA和LR(1)是一种操作

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320150207347.png" alt="image-20230320150207347" style="zoom:80%;" />



**step 3：求follow集**
![image-20230423213419469](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423213419469.png)



**step 4：做分析表**

![image-20230423213502714](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423213502714.png)

上面是添加的分析

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320150333580.png" alt="image-20230320150333580" style="zoom:80%;" />

​	**区别：**区别在于，对于r，这里不是填满一整行，而是只对follow进行填写

​	**判断是否为SLR（1）：**将**⋅ 后面**的所有终结符和前面所有非终结符的FOLLOW集进行对比，是否为空串。比如I1中的，{ + } ∩ FOLLOW(S’) = Φ

​	再举一个例子，这里的FOLLOW(M)={a,c}，所以.后面的c和前面的有交集，这时候就不能算作ok的SLR。因为.后有终结符c，左边的non-terminal的Follow集和其重合了

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320164551116.png" alt="image-20230320164551116" style="zoom:50%;" />

#### 2.3.3 LR(1)

*A*→*α*.*β*, *t* 表示 ![img](https://cdn.nlark.com/yuque/__latex/7b7f9dbfea05c83784f8b85149852f08.svg) 在栈顶，而且未来的输入将会是 ![img](https://cdn.nlark.com/yuque/__latex/f58b366dc703dff98777b36c5ea39699.svg)

**step 1：构造拓广文法**

**step 2：构造对应的DFA**

​	但是区别在于，I0不一样了，这里I0的逻辑是：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320151358384.png" alt="image-20230320151358384" style="zoom:50%;" />

​	由0）可以推导出1式【0):左边橙色框中的式子 1：右边蓝色框中的式子】，1式中的S是非终结符，所以又可以继续推出等价项目2和3。又2式中圆点后面的L属于非终结符，继续推出4、5式【**注意：4、5中的展望符是=，因为2式中L后面有终结符=**】然后继续对左边橙色框中的式子进行相同算法的推导即可。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320151301200.png" alt="image-20230320151301200" style="zoom:50%;" />

​	接着再做一次简化，将展望符合并，这里把=/$合并到了一起

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320151731519.png" alt="image-20230320151731519" style="zoom:50%;" />

**step 3：求follow集**

**step 4：做分析表**

![image-20230320151807743](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320151807743.png)

**判断方法**：如果以此法构造出的 Parsing Table 没有冲突项，则说明文法是 LR(1) 的



#### 2.3.4 LALR(1)

参考链接：[(60条消息) LALR(1)分析方法_用编程写诗的博客-CSDN博客](https://blog.csdn.net/m0_53345417/article/details/127337022?ops_request_misc=%7B%22request%5Fid%22%3A%22167929122316800226563961%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167929122316800226563961&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127337022-null-null.142^v74^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=LALR(1)&spm=1018.2226.3001.4187)

​	**可以观察到其中** **I** **3** **和** **I 6**， **I** **4** **和** **I** **7** **,** **I** **8** **和** **I** **9** **项目集可进行合并**，进行一次状态合并：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320151902151.png" alt="image-20230320151902151" style="zoom:50%;" />

​	将转换表

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320152027803.png" alt="image-20230320152027803" style="zoom:50%;" />

​	合并状态后转为：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320152045235.png" alt="image-20230320152045235" style="zoom:50%;" />

问题：当我们碰到C之后向前搜索符都是d/e那么我们就不知道是规约到A或者B了。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230320170607972.png" alt="image-20230320170607972" style="zoom:50%;" />





### 2.4 Yacc

#### 2.4.1 冲突

​	**移入--归约冲突**：某一产生式的右部是另一产生式的前缀

​	举例而言，下面的X，你既可以继续移入一个a，然后再等着归约到U，也可以直接归约到X，这里就产生了冲突

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402145112044.png" alt="image-20230402145112044" style="zoom:50%;" />

​	**归约--归约冲突**：不同产生式有相同的右部 或者 产生式的右部是另一产生式的后缀

​	举例而言，当遇到X之后，有多种可以做归约的方案，不知道归约到哪一个

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402154106089.png" alt="image-20230402154106089" style="zoom:50%;" />

#### 2.4.2 优先

​	为了设置优先级，yacc可以用如下的方法：

```yacas
%left PLUS
%left TIMES
%right EXP
exp :	exp PLUS exp
		|exp TIMES exp
		|MINUS exp %UMINUS
```

​		一方面是通过**left写法顺序**，另一方面是通过**%UMINUS**这样的写法强行提高

#### 2.4.3 语法语义

​	若a是一个bool量，那么a & b是一个合理操作，若a是一个int量，那么a &b将不是一个合法操作。

​	**语法上合规的一个式子，在语义上可能会有问题**，所以bison使用的方法是将分析推迟到语义分析

#### 2.4.4 错误恢复

​	目的：能够不只是报告一个错误，而是能够报告所有的错误

- 一种方法是用error进行修复：思想是把error看作是一个终结符，并对error进行移进

- 另一种方法是做全局错误修复，这里使用的是**Burke-Fisher error repair**，通过在错误位置，来回寻找前后K个，通过删除替换插入来实现修复，一般修复后能**再做3-4步**就是好的

  ​	例如：现在输入字符串为`id + id * id ( id`，其中缺少了一个右括号")"。如果使用LR(1)分析法对这个字符串进行分析，会发现在状态5时无法进行下一步操作，存在归约-归约冲突，此时可以使用Burke-Fisher算法进行错误修复。算法会尝试添加一个右括号")"来解决问题，得到字符串`id + id * id ( id )`，然后就可以成功进行分析。

  ​	下面是对应的表：

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402162855134.png" alt="image-20230402162855134" style="zoom:50%;" />



## Part 3.抽象语法

### 3.1 语义动作

#### 3.1.1 YACC分析器分析

​	下面是这段文法的分析器

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402184710592.png" alt="image-20230402184710592" style="zoom:50%;" />

- **名称与数据类型的对应**：这里定义了ID必须是string类型的，num必须是int类型的

- 函数：advance指的是跳过一个symbol

- 函数：eat指的是跳过一个对应的符号

- 函数：Tprime，由于文法原是T*F，但为了消除左递归，出现了T‘-> * FT’的状况，因此缺少了左操作数，所以把左数作为参数由T传递给T‘，**比如Tprime(F())**

  first、follow集：

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230422160547373.png" alt="image-20230422160547373" style="zoom:50%;" />

  预测分析表：

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230422160505848.png" alt="image-20230422160505848" style="zoom:50%;" />

  递归下降分析器：

  

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402184435377.png" alt="image-20230402184435377" style="zoom:50%;" />



#### 3.1.2 命令式风格解释器

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402185033699.png" alt="image-20230402185033699" style="zoom:50%;" />

#### 3.1.3 区别

​	递归下降解析器和命令式风格的解释器在设计和实现上有很大的区别

1. 解析过程： 递归下降解析器采用**自顶向下**的方式进行语法分析，从输入符号开始不断递归**调用子过程**直到推导出完整的句子。而命令式风格的解释器则更加类似于编译器，采用**自底向上**的方式分析语法树，一次执行一个操作指令并更新程序状态。
2. 控制结构： 递归下降解析器中主要使用递归函数和**条件**语句等控制结构来判断语法正确性和执行顺序。相比之下，命令式风格的解释器则使用较多的循环、分支和跳转语句等来控制程序流程和处理运算。
3. 存储结构： 递归下降解析器常常使用栈或堆栈等数据结构来维护程序执行过程中的状态信息，例如中间结果、运算符、括号等。而命令式风格的解释器则更倾向于使用变量、表格、指针等动态分配和管理的数据结构。
4. 代码复杂度： 递归下降解析器通常需要定义较多的函数和递归规则来处理各类语法结构，同时也需要考虑错误恢复、优先级和结合性等问题。相比之下，命令式风格的解释器通常会采用更加简单直白的代码风格，通过一些模块化和封装技巧提高代码复用和可读性。

#### 3.1.4 Yacc特性

​	这里的特性很显然，感觉会出理论题

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230613130327812.png" alt="image-20230613130327812" style="zoom:50%;" />

### 3.2 抽象语法分析树

#### 3.2.1 定义

​	语法分析树是一种数据结构，它对文法的依赖度高。

- parse tree：has exactly **one leaf for each token** of the input and **one internal node for each grammar rule** reduced during the parse.
- concrete parse tree：represent the **concrete synax** of the source language 
- abstract parse tree：conveys the phrase structure of the source program, with all parsing issues resolved(解决了所有语法分析问题) but without any semantic interpretation.（不带任何语义解释）

- 区别：ast树不带有语义解释，直接显示了如何做

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230613131146248.png" alt="image-20230613131146248" style="zoom:50%;" />

​	

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230613131159991.png" alt="image-20230613131159991" style="zoom:50%;" />

- every grammars for the same language will give different parse trees but should result to the same AST
- AST doesn't focus on the ways they are generated by a grammar.AST focuses on programming constructs。
  - ASTs uses operators/operations as root and interior nodes and it uses operands as their children
  - ASTs do not use interior nodes to represent a grammar rule, unlike the parse tree does.
  - ASTs don’t represent every detail from the real syntax (that’s why they’re called abstract) - no rule nodes and no parentheses, for example.
  - ASTs are dense compared to a parse tree for the same language construct

#### 3.2.2 pos

​	**定义：**一个非终结符号 pos，其语义值是一个源代码位置（行号或行内位置）。由于在实际操作中，是先进行了词法分析，然后再对AST树做操作，如果不存储pos，因为词法分析已经在末尾，无法报告是代码的哪里出错

​	**作用：**在编写文法时，可以引入一个名为 pos 的非终结符号，用于表示当前处理的产生式的位置信息。pos 非终结符的语义值通过代码计算得出，并存储在抽象语法树（AST） 中，以便在出现错误时精确定位错误位置并向用户报告。

​	**例子：**a + b * (c + d)

​	可以将其文法表示为：

```
	expr : expr '+' term { $$ = Add($1, $3, pos); } 
		| term { $$ = $1; }
	term : term '*' factor { $$ = Mul($1, $3, pos); } 
		| factor { $$ = $1; } 、
	factor : '(' expr ')' { $$ = $2; } 
		| NUM { $$ = Num($1, pos); } 
		| ID { $$ = Id($1, pos); }
```

​	其中，Add、Mul、Num、Id 等函数都是自定义的 AST 节点构造函数，用于创建相应的节点，同时将 pos 作为参数传递进去。这样就可以在**出错时通过访问 AST 树定位错误位置**，以更好地辅助用户进行调试和问题排查。

#### 3.2.3 实例

​	以下是一个代码实例：通过构建语法树节点的方式建立数据结构

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230402190044156.png" alt="image-20230402190044156" style="zoom:50%;" />



### 3.3 习题分析

- 将命令式风格=>递归下降型分析器的做法
  - 首先转换出文法
  - 将文法 **去除二义性（比如加减法会存在先后关系，要设计语法）和左递归**
  - 转换First+Follow集
  - 关注**实际语法**， 写出答案



## Part 4. 语义分析

### 4.1  Symbol Table

#### 4.1.1 定义

- 举例：假设一开始关于形式参数得到了σ1{int a,b,c}，经过j得到了σ2{int a,b,c}+{int j}，经过a又得到了σ3{int a,b,c}+{int j}+{string a}，此时对a进行使用时，**需要使用string a的定义形式**

```C++
function f(a:int, b:int, c:int) =
 (print_int(a+c);
 let var j := a+b
 var a := "hello"
 in print(a); print_int(j)
 end;
 print_int(b)
 )
```

- 为了实现参数指代的变化，共有两种形式

  ​	**函数式**：keep σ1 in pristine condition while we create σ2 and σ3. 有多个σ，共存

  ​	**命令式**：全局只有一个符号表，但是符号表动态变换。 即每次都会修改σ，当不需要时再重新恢复成之前的σ，上述过程就有σ becomes σ0, σ1, σ2, σ3, σ1, σ0 不断变化，但是全局中有an “undo stack” with enough information to remove the destructive updates

#### 4.1.2 多符号表

​	受编译语言影响，不同的语言编译时符号表不同，这是受语言特性所决定的

​	例如下列语言中，ML语言不允许在N中出现D.d，但是Java语言式允许的，也就是说在Java中，E、N、D使用同一个负号表，而ML语言则是E、N、D各自拥有一个符号表

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230414191448463.png" alt="image-20230414191448463" style="zoom:50%;" />

#### 4.1.3 命令式符号表

​	使用 **Hash** 表完成操作，具体思路如下

​	假设有a->σ1 , 现有 a->σ2， 则把 a->σ2插入到 a 对应的hash表的表头位置，待到 a->σ2 使用完毕， 再pop出对应位置的 Hash表即可实现操作



#### 4.1.4 函数式符号表

​	函数式符号表可以使用binary search trees二叉搜索树快速进行实现，其思路是：在d层添加一个节点，只要新创建d个节点，不需要复制整个树



#### 4.1.5 Tiger的参数操作

- Tiger使用的是命令式的摧毁类型

- 表达式的类型检查：检查a+b这样的式子，a和b的类型是否一样
- 声明的类型检查：用S_beginscope开启一个新作用域，进行操作，再用S_endscope结束这个作用域，检查时先名称再检查体

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230414200956673.png" alt="image-20230414200956673" style="zoom:50%;" />

​		这里较为重要的是关于函数的：

​		function f(a: ta, b: tb) : rt = body，以这段代码举例子，首先会再环境中查找return类型rt，是否合理；再用makeFormalTyList构造参数列表，然后送入环境，再不断送入环境中临时变量；开始遍历整个主体；退出环境

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230414201255453.png" alt="image-20230414201255453" style="zoom:33%;" />

- 递归声明：先查头，再查体，不能出现嵌套递归问题，比如{type a=c b=c c=a}就是错误的

### 4.2 编译器的绑定

#### 4.2.1 定义

​	**属性 (attributes)** 包括编程语言组件的任意特性。例如，标识符的属性就包括其种属（变量、数组、函数名等等）、数据类型、存储位置、长度、值、作用域等。

​	属性的确定时间是有多种可能的。属性值的计算以及将计算出来的值与相关的语言结构进行联系的过程称为属性的 **binding**，发生的时间称为 **binding time**。在程序执行之前就进行 binding 的属性称为 **static attributes**，函数、变量等；在程序执行过程中才进行 binding 的属性称为 **dynamic attributes**，虚函数、多态等。

#### 4.2.2 等价

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230613134329729.png" alt="image-20230613134329729" style="zoom:50%;" />

- 结构等价		 两个类型当且仅当他们有相同的结构，即语法树时才相同。一般要求数组大小相同、结构体顺序相同，但是也可以不同。
- 名等价		当且仅当两个类型有相同的类型名时才等价。

- - 例如，定义 typedef t1 = int, typedef t2 = int，但是 `t1`, `t2`, `int` 仍然两两不等价

- 说明等价		弱化版的名等价，即别名之间可以等价。

- - 在上面的例子中，这三个类型等价。

​	

**Tiger的奇怪特性**

![image-20230613134604511](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230613134604511.png)

### 4.3 表达式的类型检查

### 4.4 习题分析

- Double表：重新设计两个函数（insert+reharsh）-insert做一个额外判断，需要统计backetnum与size的关系判断是否要扩大，reharsh的工作是首先重新申请一个bucket，然后对于原先的所有的元素重新insert一次（**很有趣的是，insert里还有一个子函数bucket，使得模块化容易**）
- 多表：多表就是加了num参数，在插入和查找时都可以指定表

```C++
void insert(string key,void * binding,int num)
{
	int index=hash(key)%SIZE;
	table[num][index]=Bucket(key,binding,table[index]);
}

void * lookup(string key,int num)
{
	int index=hash(key)%SIZE;
	struct bucket * b;
	for(b=table[num][index];b;b=b->next)
		if(0==strcmp(b->key,key))return b->binding;
	return NULL;
}

```



## Part 5 活动记录 

### 5.1 基础概念

#### 5.1.1 课本引入

- 课本引入：有一些函数内的局部变量，其需要的生命期可能超过了函数的生命期，比如下面的f(3)，再使用h(5)的时候，我们依旧需要3这个值
- pascal和tiger允许函数嵌套，不允许函数作为返回值-**可使用栈**
- C允许将函数作为返回值，不允许函数嵌套-**可使用栈**
- ML、Scheme等语言允许函数作为返回值也允许函数嵌套-**不可使用栈**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230612170752941.png" alt="image-20230612170752941" style="zoom:50%;" />

- 栈通常只在入口处增长，出口处收缩
- 栈中用来存放函数的局部变量、参数、返回地址、其他临时变量的区域称之为activation record或stack frame

- 存储的内容有：incoming argument;return address;local variables;outgoing argument；stack links

#### 5.1.2 语雀引入

​	我们将较小的编译时常量直接插入到代码中；而对于大的整型值、浮点值、字符串分配到全局/静态区域中的存储器，在启动时仅保存一次；之后再由执行代码从这些位置中得到

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520155343826.png" alt="image-20230520155343826" style="zoom:50%;" />

​	而存储器分配时的一个重要单元是 **过程活动记录 (procedure activation record)**，其用途是保存调用函数时产生的局部数据。其至少应当包含如下几个部分：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520155536060.png" alt="image-20230520155536060" style="zoom:50%;" />

​	几乎所有的程序语言都依赖于如下 3 种 runtime environment 的某一个，其主要结构并不依赖于目标机器的特定细节：

- - FORTRAN77 的完全静态环境
  - C, C++, Pascal, Ada 等的基于栈的环境
  - LISP 等的完全动态环境

​    这三种类型的混合模式也是可能的。



### 5.2 基于栈的环境

#### 5.2.0 课本概念

##### 5.2.0.1 control link

​	课本内，这一章重点只讲了基于栈的环境，因此这里也只记录下基于栈的环境。

- 例题引入，可以看到sp指向的是当前的control link，sp指向末尾

![image-20230612173815135](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230612173815135.png)

##### 5.2.0.2 Register

​	当f调用g时，如果f用了寄存器r，g也用想r，那么要对r进行保护（比如g先存这个r的值，等g结束再还原这个r），通过这个r靠谁来保护，分为caller-save register（f保护）和callee-save register（g负责保护）

##### 5.2.0.3 Paramter passing

​	现代机器中，传递参数时前4-6用寄存器传，剩余的用内存传。但是会出现函数调用函数的情况，比如f(a,b,c)调用g(z)，此时z要用的寄存器被占了，有四个方案

- 一些函数不会调用其他函数，称之为leaf procedures，不需要write their incoming arguments to memory
- 一些编译器可以自动优化，使得编译器顺序变化，a-r1,z-r7
- g(z)时a不会再被用到，此时这个寄存器没作用，直接使用
- 一些体系结构有寄存器windows，不会有memory traffic
- 把放在寄存器里的值放到内存里去

​    但是一些语言，例如C语言里需要参数的连续性

##### 5.2.0.4 Return address

​	f在a处调用了g，返回的时候返回到a+1，现代机器使用一个寄存器来保存这个返回地址。非叶把返回地址放到栈帧中（除非有特殊的过程间寄存器），叶子不需要保存，有寄存器

##### 5.2.0.5 栈内变量

- 放在寄存器：function parameters;return address;function result

- 放在内存（也就是**放在stack frame**）：

  
  
  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230612203139849.png" alt="image-20230612203139849" style="zoom:30%;" />
  
  

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230612203156766.png" alt="image-20230612203156766" style="zoom:30%;" />

- 翻译如下
  - 被用作传地址参数的变量，也就是加了&的变量
  - 该变量被嵌套在当前过程内的过程访问（但并不是绝对的，有时也可放在寄存器中）
  - 变量值太大了不能放到单个寄存器中（但是有的编译器选择用多个寄存器，而不是放到内存）
  - 该变量是一个数组，为了引用其地址
  - 存在太多局部变量和临时变量，放不下时，需要放一部分进内存里
  - 

##### 5.2.0.6 静态链

​	内部函数调用外部函数的变量，这种情况叫：block structure，有三个解决方法，分别是调用时传一个指针的静态链；建立全局数组的display；作为额外参数的lambda lifting

​	ppt额外对比的概念：Static links represents the defining environment of the procedure; Control  link represents  the calling  environment of the procedure. 

​	关注assess link的概念，在下面的语雀里有



#### 5.2.1 没有局部过程的基于栈的环境

​	用 sp 指向当前栈顶，一个框架指针 (frame pointer, fp; a.k.a 帧指针, bp) 指向当前活动，这两个指针通常保存在寄存器中。先前活动的 fp 会保存在它调用的函数的活动记录中，形成控制链 (control link; a.k.a 动态链, dynamic link)

​	举例而言，如果是

```C++
void p(){}
int main(){
	p()
}
```

​	那么此时，在mian调用了p之后，main的fp会存在p的活动记录中

#### 5.2.2 带有局部过程的基于栈的环境

##### 5.2.2.1 示例

​	如下面的程序所显示的，这个时候q和r是p的局部过程，它们都应该能访问到p的变量n

```pascal
program nonLocalRef;

procedure p;
var n: integer;

    procedure q;
    begin
        (* a reference to n is now*)
        (*non-local non-global *)
    end; (* q *)
    
    procedure r(n: integer) ;
    begin
        q;
    end; (* r *)
    
begin (* p *)
    n := 1;
    r(2);
end; (* p *)

begin (* main *)
    p;
end.

```

​	为了能让p和r都能访问到这个n，因此会有下面的q和r的活动记录指向p的access link：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520162430723.png" alt="image-20230520162430723" style="zoom:50%;" />

##### 5.2.2.2 三条规则

​	为了能正确指示，一共出现了三条规则

1. `y`的嵌套深度大于`x`的嵌套深度，那么`y`一定是直接在`x`中定义的，即嵌套深度差距为 1，否则`x`根本访问不到这个`y`。即：

```pascal
procedure x;
  procedure y;
  ...
...
```

2. x和y的嵌套深度相等。这种情况下，它们要么是同一个函数调用自己的递归调用，要么是直接定义在全局或者同一个 procedure 内部的，即：

```pascal
procedure r;
  procedure y;
  ...
  procedure x;
  ...
...
```

3. `y`的嵌套深度小于`x`的嵌套深度。但是既然这时`x`仍然能调用到`y`，那么要么`y`定义在全局，要么`y`直接定义在一个过程`r`内部，而`x`嵌套定义在`r`内部的某一层，即：

```pascal
procedure r;
  procedure y;
  ...	(* y *)
  procedure s1;
    procedure s2;
      ...... 
        procedure sn;		(* n >= 1 *)
          procedure x;
          ... (* x *)
        ... (* sn *)
      ......
    ... (* s2 *)
  ... (* s1 *)
... (* r *)
```

​	因此这时，`x`需要经过![img](https://cdn.nlark.com/yuque/__latex/cb6ef8f7a324708da3c0600f4852064d.svg)次 access link 找到`r`的 activation record，然后将这个地址赋值给 `y`的 access link 即可。

​	等价地，`x`需要经过![img](https://cdn.nlark.com/yuque/__latex/28526e80280cacf42b8195916b3745fd.svg)次 access link 找到`s1`的 activation record，然后将`s1`的 access link 赋值给 `y`的 access link 即可。

​	由此带来了一个例题分析：

```pascal
program env;

procedure a;
var x: integer;
  procedure b;
    procedure c;
    begin
      x := 2;
      b;
    end;
  begin (* b *)
    c;
  end;
begin (* a *)
  b;
end;
	
begin (* main *)
	a;
end;

当第二次调用c的时候
main和a是全局的，所以其深度都是0
name      accesslink
main				null
a						null
b           a(a调用b,深度0调用深度1)
c           b(b调用c,深度1调用深度2)
b           a(c调用b，深度2调用深度1，属于”y直接定义在一个过程r内部，而x嵌套定义在r内部的某一层，要找到r的活动记录给y”)
c						b(b调用c，深度1调用深度2)
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520163238928.png" alt="image-20230520163238928" style="zoom:50%;" />

#### 5.2.3 带有过程参数的基于栈的环境

​	在一些语言里，过程也可以作为参数。其中的问题是，过程r是可以使用q的参数x的，那么在p(r)中的，要**让p里面能想办法找到这个x**

```pascal
program closureEx(output);

procedure p(procedure a) ;
begin
  a;
end;

procedure q;
var x: integer;

  procedure r;
  begin
    writeln(x);
  end;
  
begin
  x := 2;
  p(r);
end; (* q *)

begin (* main *)
  q;
end.
```

​	于是，便传了一个新东西ep，其指向的是原来的环境，方便能找到那个自变量<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520163412994.png" alt="image-20230520163412994" style="zoom:50%;" />

### 5.3 存储概念

​	看书上的例题，其中a是引用类型

![image-20230520163909951](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520163909951.png)



## Part 6 翻译成中间代码

### 6.1 基础定义

​	 本章节处于IR Generation部分。IR 在减省工作量上的重要意义，编译器的前端进行词法分析、语法分析、语义分析，并且产生中间表示；而编译器的后端对中间表示进行优化，并且将中间表示翻译成机器语言。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520165136760.png" alt="image-20230520165136760" style="zoom:50%;" />

#### 6.1.1 Three-Address Code

​	三地址码用来表示算术表达式求值，形如 `x = y op z`；例如下图 AST 对应的三地址码就是：

```C++
t1 = 2 * a
t2 = b - 3
t3 = t1 + t2
```

​	并且，三地址码也可以延伸成很多种类：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606211737723.png" alt="image-20230606211737723" style="zoom:30%;" />

​	对于三地址码，保存其信息需要 3 个地址以及 1 个操作符。因此我们用 **四元式 quadruple** 的方式来存储三地址码。`_`表示不需要使用的地址，置为空。例如上面的三地址码用四元式表示就是：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606211914724.png" alt="image-20230606211914724" style="zoom:50%;" />



### 6.2 中间表示树

​	在本书中，使用中间表示树结构，下面先记录下树中符号的定义：

#### 6.2.1 基础变量

​	首先是常数，临时变量和符号常数

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520165753186.png" alt="image-20230520165753186" style="zoom:50%;" />

#### 6.2.2 基础计算

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520170010356.png" alt="image-20230520170010356" style="zoom:80%;" />



#### 6.2.3 推论和字符串、数组、记录

- 简单变量：一种化简形式

- 追随静态链：我们知道有时候，一个值是一层层嵌套得出的，此时为了得到一个值要经过多次偏移与基地址的加和

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520184620237.png" alt="image-20230520184620237" style="zoom:50%;" />

- 左值和右值：简言之，左值是出现在等号左边的，可以变化的内容，右值是只能出现在等号右边的，例如a+2,f(x)。而左值也能出现在右边

- 数组值：有些语言如C，数组是指针常数，a=b是地址的复制；而有些语言如Pascal，a=b则是整体值上的复制

- 取数组中的a[i]，地址为（i-l）*s+a，如果a是全局的，那么a-l * s可以在编译时就算好，类似的，为了选择左值中的a.f，只要直接把位移和a相加就好。

  **可以对左值施加MEM操作使得它成为右值，左值是地址，右值是值**

  a如果a是memory-resident array variable（分配在存储器的数组变量，数组放在内存也很常见默认），于是a[i]可以有如下的一个表示方式

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520185222382.png" alt="image-20230520185222382" style="zoom:50%;" />

- 安全性警告：需要检查数组越界的安全性，优化编译器在进行静态分析时，也可以将这些边界检查从代码中优化掉，以提高程序的执行效率。但在这个过程中，需要保证程序的运行时安全性，并采取一定的措施避免出现缓冲区溢出等安全隐患

- Tree语言没有**一元**运算符，要用二元运算去进行

- 字符串：所有字符串操作都由运行系统提供的函数来完成，这些函数为字符串操作的结果分配堆空间，并返回指针

- 记录与数组：现在展示创建一个记录（数组是类似的），该记录的特征是：

  - 一位的偏移是W
  - 初始地址是r
  - 值分别是e1,e2,e3...，en
  - 创建的时候先malloc空间到r里，然后不断的把值放进偏移对应的位置

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520190226436.png" alt="image-20230520190226436" style="zoom:67%;" />

#### 6.2.4 语句

##### 6.2.4.1 顺序语句

​	这里展示一句c=a+1; c*c

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616155842039.png" alt="image-20230616155842039" />

##### 6.2.4.2 条件语句

​	这里展示if语句 `if a<b then c=a else c=b`:

​	分析如下：首先由一个CJUMP确认两类跳转，再有seq做连接，其中的n LABEL是if的结束

<img src="D:\大学\大三下\编译原理\学习笔记.assets\image-20230623184358632.png" alt="image-20230623184358632" style="zoom:50%;" />



##### 6.2.4.3 循环语句

​	这里展示while语句 `while a>0: a=a-1`

​	循环语句有：初始化，循环体，循环条件判断

​	分析这里的示例：首先，有4个标签，分别是循环条件标签z，循环体标签z2，还有为了凑CJUMP的标签z1，循环体结束后的n

​	如果a>0已经不存在了，会跳转到z1，再由SEQ跳到循环体结束的n

​	如果还要继续做，那么就是从z2那里继续做，知道SEQ全做完重新跳回判断z

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520191049871.png" alt="image-20230520191049871" style="zoom:50%;" />





**另外一份答案**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616160204021.png" alt="image-20230616160204021" style="zoom:50%;" />



#### 6.2.5 声明

- Variable declaration within a function body–additional space will be reserved in the frame.当在函数体内部声明或定义变量时，编译器会为每个变量分配一定的存储空间
- function declaration–a new "fragment" of Tree code will be kept for the function's body.而当声明函数时，编译器会为该函数分配一段新的代码区域，用于存储函数体中的代码

##### 6.2.5.1 变量定义

具体来说，将函数转换为汇编代码需要分为三个部分：前奏（prologue）、主体（body）和结尾（epilogue）。

前奏部分包含了一些伪指令（pseudo-instructions），用于标记函数的开始、定义函数名以及调整栈指针。此外，还需要进行参数和寄存器的保存和初始化操作，确保函数能够正确访问其参数和内部变量。具体来说，需要将传递给函数的参数存储到函数堆栈帧中，并将非逃逸参数存储到新的临时寄存器中，以便更方便地访问它们。同时，除了通过寄存器保存的callee-save寄存器，还需要保存返回地址寄存器，以便在函数返回时能够正确跳回调用函数。

主体部分就是函数实际执行的代码了。这部分代码的具体内容取决于函数的实现，可以是一组简单的算术运算、一段复杂的条件逻辑或者是函数间的递归调用。这部分代码需要符合汇编语法和语义规范，并遵循一定的编码规范，以便计算机在执行时能够正确理解。

结尾部分是函数执行结束后需要进行的操作。这部分代码需要包含将返回值（函数的结果）移动到寄存器中、恢复callee-save寄存器、重设栈指针、返回到调用函数等指令。这样，才能保证函数的执行过程和结果都是正确的。

总之，将函数转换为汇编代码需要涉及到前奏、主体和结尾三个部分，其中前奏和结尾部分主要是为了函数的正确性和稳定性而进行的特殊操作，而主体部分则是实际执行函数功能的核心部分。

### 6.3 习题分析

- 如果只是一个EXP不是一个stmt，要标出EXP

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616160112988.png" alt="image-20230616160112988" style="zoom:33%;" />

- 如果是下面的加法，似乎要加上TEMP的标签

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616160232202.png" alt="image-20230616160232202" style="zoom:50%;" />

## Part 7 基本块与轨迹

### 7.1 基础概念

​	本章节位于IR Optimization部分。

​	我们在初论中就提过使用的是树形结构，但是其和机器语言与编译器优化有时会产生冲突。在本书中的，上面介绍的所有画法中，存在不匹配真实机器语言的情况：CJUMP（真实世界为假是直接跳转到后一句，而不是可以任意跳）、ESEQ（使得子树的不同顺序产生不同值）、call；但是它们存在的意义是，有利于编译器的Translate阶段。并且，有方法可以进行**等价性转换**。

![image-20230520191733127](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520191733127.png)

​	也就是linearize(消除eseq，将call移动到顶层)、basic blocks(一组语句序列)、Trace schedule（使得每一块后面的block就是cjump为假的跳转）

### 7.2 规范树

​	规范树指的是：没有SEQ与ESEQ，并且call的父节点是exp或者move

#### 7.2.1 ESEQ转换

​	整体方法是**在树中一级级的网上提升，直至ESEQ变为SEQ**。书中，为我们提供了规则

​	（1）的思路：要执行e是s1和s2都要有effect，等价于SEQ这个s1,s2然后看是否有effect，再做e

​	（2）的思路：如果s有effect，做e1和e2的运算，这里注意**两个JUMP**

​	（3）的思路：有时，不能交换s和e1的交换，比如s是MOVE(MEM(x))，e1是BINOP(PLUS,MEM(x),z)，交换会导致语句出问题，这时引入一个临时变量，再做交换

​	（4）的思路是，引入commute来判断能不能换，能的话直接转，commute的思路是：常数可以与任何语句交换，空语句可与任何表达式交换，其余的都不能交换。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520192025635.png" alt="image-20230520192025635" style="zoom:67%;" />

​	如果不能commute的话，那么必须要**进行TEMP赋值**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606191649702.png" alt="image-20230606191649702" style="zoom:50%;" />

#### 7.2.2 CALL转换

​	需要进行这一步的原因是，CLL函数将会把结果返回到同一个返回值寄存器TEMP（RV）中。为了防止覆写寄存器，将每一个CALL的结果能存在TEMP t里，然后通过ESEQ返回这个t

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520192843011.png" alt="image-20230520192843011" style="zoom:50%;" />

#### 7.2.3 线性语句表

​	最后，得到结果：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520193038356.png" alt="image-20230520193038356" style="zoom:50%;" />

​	并且有转换规则

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520193015558.png" alt="image-20230520193015558" style="zoom:50%;" />

​	

### 7.3 条件分支处理

#### 7.3.1 基本块

​	基本块是符合以下定义的：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520193152415.png" alt="image-20230520193152415" style="zoom:50%;" />

​	而切分基本块的方法：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520193505591.png" alt="image-20230520193505591" style="zoom:50%;" />



#### 7.3.2 轨迹与完善

​	轨迹生成：即基本块的可能执行顺序，我们从a开始一直随意的做，直到做不下去了，就重新从还没标记的基本块里开一条新的轨迹。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616191444144.png" alt="image-20230616191444144" style="zoom:50%;" />

​	优化：（1）把许多无条件跳转（unconditional JUMP）紧接着其目标标签的基本块排在一起，并删除这些无用的跳转语句（2）把CJUMP后面紧跟其false情况的跳转

​	完善：有些语句CJUMP(cond,a,b,lt,lf)这样的句子，若这一整句后面跟的就是lf的，那么不变；若后面紧跟的是lt的，那么交换lr与lf；如果碰到了后面跟的既不是lt也不是lf，则作下面的改变

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520193842589.png" alt="image-20230520193842589" style="zoom:50%;" />

​	最优轨迹：频繁的循环体有单独的轨迹，其中的迭代跳转要最少，这里显示了同样的一些语句，不同的轨迹，其中C的跳转最少。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606193723795.png" alt="image-20230606193723795" style="zoom:50%;" />

### 7.4 家作分析

#### 7.4.1 hw8.2

第一问：这道题的想法是，如果达到了ESEQ是条件，那么做Move，不然不做，似乎牵涉着的是Move(MEM(ESEQ(a,b),c))=>ESEQ(a，Move(Mem(b),c))

![image-20230616163716833](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616163716833.png)

第二问：这道题需要首先把call做一个转换，然后运用一个Move(a,eseq(b,c))=>ESEQ(b,move(a,c))这样一条规则（**没有写在公式里**），思想就是如果达到了b条件，那么move进去，不然不move

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616163424055.png" alt="image-20230616163424055" style="zoom:50%;" />

第三问：这个也可以意会但是很难描述，CALL会带来两个ESEQ，并且其中CALL还有一个ESEQ，在最后仿佛就是直接把所有的ESEQ的条件都放总的ESEQ左边，用SEQ做连接，然后如果左边全做成了就做右边

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616165414682.png" alt="image-20230616165414682" style="zoom:50%;" />

#### 7.4.2 8.6+8.7

- 划分基本块的时候，要注意jump到的语句往往是一个block的开始
- 这里涉及到的轨迹划分，就是使劲连，因为无条件跳转而被迫结束，所以只有3个留下
- 转成tree的中间形式，其实也就是完成语句的对应转换

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616191919829.png" alt="image-20230616191919829" style="zoom:50%;" />

## Part 8 指令选择

### 8.1 树型

​	在这里，很重要的是树型与合理的机器指令的一种对应转换，目标就是use no overlapping tiles to cover the IR tree

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520194330245.png" alt="image-20230520194330245" style="zoom:50%;" />

​	由于参考资料的缺少，只知道这里的一些示例：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520194458969.png" alt="image-20230520194458969" style="zoom:50%;" />

​	并且，有如下的对应：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520194519956.png" alt="image-20230520194519956" style="zoom:50%;" />

### 8.2 指令选择算法

- 覆盖有两个概念，最优（optimum）覆盖和最佳（optimal）覆盖。
  - optimum是总和代价最小。
  - optimal是没有两个瓦片可以合并
- optimum一定也是optimal，而对optimal的覆盖是更为简单的。对于CISC，两者差别明显，对于RISC，两者差别不大

#### 8.2.1 Maximal Munch

​	the alogrithm for optimal tiling，从根节点开始找最大覆盖，找到后，对剩下的子树，也从其根开始继续找最大的覆盖，直到再也没法找到

- 从根节点开始，寻找合适的最大瓦片（包含最多节点的），如果有两种方案，任选。

- 对子树进行相同算法。

- 本质上就是贪心算法，自上而下找，寻找局部最优，全局不一定。

  

#### 8.2.2 动态规划

​	从底层节点开始匹配，找最优的方法不断向上

- 递归求出节点n的所有儿子和孙子的代价
- 将每一种树型与节点n进行匹配

​    书上给出的例子如下：

​	假设要做一个1+2这样两个常数的加法，那么采取不同的瓦片得到不同的结果，如果用ADD的话，需要把叶子的代价先求出，拿一个const的代价是1，所以第一行就是先把两个const放到寄存器里再做加法，因此是1+1的叶子代价和一个加法的1代价。

​	而下面两行都是用不同的瓦片，只需要把一个const放到寄存器里，然后就可以直接做了

​	

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522194151335.png" alt="image-20230522194151335" style="zoom:50%;" />

​	再看一个，第一行是运用了上面的最优代价作为子代价，下面则是用了不同的瓦片。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522194609597.png" alt="image-20230522194609597" style="zoom:50%;" />

​	一旦求出了根节点（也就是整棵树）的代价，便进入到指令流出阶段（**instruction emmsion**），从下到上构建指令。

​	比如上面的就是：

​	ADDI R1<-R0+1

​	LOAD R1<-M[r1+2]

#### 8.2.3 树文法

​	基于树形语法的算法，这种算法是动态规划算法的一种扩展形式。而这种算法特别适用于指令集比较复杂、寄存器和寻址模式比较多的计算机。它的好处是，**可以在编译过程中自动选择最佳的寄存器和寻址方式，从而减少程序的指令数和执行时间**。

​	jouette结构：a registers for addressing, and d registers for data。并且提出，用上下文无关文法来描述瓦片，虽然这有很大的歧义性，但是不影响动态规划

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522195322754.png" alt="image-20230522195322754" style="zoom:50%;" />



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520194833224.png" alt="image-20230520194833224" style="zoom:50%;" />

#### 8.2.4 Fast Matching

​	之前的方法，都要完整的查看很多节点（包括叶节点），才能看清匹配关系，这样会碰到缓慢的问题，这里提出一个快速匹配的方法，直接对节点n进行匹配，匹配到了之后就继续匹配，找到第一个ok的就结束

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606203437855.png" alt="image-20230606203437855" style="zoom:50%;" />

### 8.3 CISC

​	简单看一下罗列的概念，感觉基本不会考到

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606203733853.png" alt="image-20230606203733853" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606203808836.png" alt="image-20230606203808836" style="zoom:50%;" />

​	此外还有一些陆续的概念，ppt上都罗列了，有多余的时间可以看一下。

### 8.4 习题分析

​	关于最大值（贪心匹配）和指令序列的转换：

- 贪心：从上到下不断找最大的，这里很显然，所有的匹配要**完全基于8.1的图**
- 指令转换：其实就是**看8.1左边这列的指令类型**，从下到上不断弄就好，比如说指令类型是ri<-M[rj+c]，所以第一条指令长这样，第二条是走addi那个，第三条走的是add，最后一条走的是ri<-M[rj+c]

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616192828924.png" alt="image-20230616192828924" style="zoom:50%;" />



## Part 9 活跃分析

### 9.1 基础概念

​	**活性分析**是编译器中的一个重要步骤，用于确定**哪些变量是活跃**的，以及**哪些临时变量在同一时刻同时被使用**。这个过程可以帮助编译器实现代码优化、寄存器分配等任务，从而提高程序的执行效率和空间效率。

​	**control-flow graph**：如果语句之后可以紧接着执行，就有一条边

​	**Liveness**：我们从后往前分析活跃性，如果x在p'语句块被使用到（**取用它的值**），那么便有一条从p->p'的活跃。

​	**example**：如图所示，b的活跃范围是{2->3，3->4}，a的活跃范围是{1->2，4->5->2}活跃（这里的a<N是对a的使用，a=b*2不算对a的使用）。这两个范围内，a/b可以放在一个寄存器里，另外的c可以放在另一个寄存器里。这就是，**靠活跃分析**，来做寄存器分配。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520195250061.png" alt="image-20230520195250061" style="zoom:50%;" />

​	

### 9.2 基本算法

#### 9.2.1 基本概念

- succ[n]，指的是出边，succ[5]={2,6}
- pred[n]，指的是入边，pred[2]={1,5}
- def(n)指的是define，指的是左边使用的变量，def(3)={c}
- use(n)指的是变量的使用，指的是右边用的变量，use(3)={b,c}
- liveness：A variable is live on an edge if there is a directed path from that edge to a use of the variable that **does not go through any def**(**也就是上面的例子，这条边通往一个use点**)
- live-in：A variable is live-in at a node if it is live on any任何 of the in-edges of that node（也就是该node有这个点）
- live-out：A variable is live-in at a node if it is live on any任何 of the out-edges of that node（也就是该node可以达到的下一个node有这个点）

​    这里的any翻译为任意的，而根据上面liveness的概念，ppt上为我们列举了三条概念推理：

- If a variable is in use[n], then it is live-in at node n. That is, if a statement uses
  a variable, the variable is live on entry to that statement.

- If a variable is **live-in** at a node n, then it is live-out at all nodes m in pred[n].

- If a variable is **live-out** at node n, and not in def [n], then the variable is also
  live-in at n. That is, if someone needs the value of a at the end of statement n,
  and n does not provide that value, then a’s value is needed even on entry to n.
  
  看不懂也没关系，对于node n来说，入口活跃集合是in[n]，出口活跃集合为out[n]

#### 9.2.2 数据流算法

- 根据上面的定义，我们要有求入口活跃和出口活跃的算法，即为如下的：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520200404335.png" alt="image-20230520200404335" style="zoom:50%;" />

- 在运算时，要不断repeat去求，直到达到不动点为止

![image-20230520200418677](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520200418677.png)

- 在实际操作中，从后往前迭代，**先计算out集合，再计算in集合**，这里就是先从6的out[n]->6的in[n]->5的out[n]->5的in[n]

![image-20230606115341254](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606115341254.png)



- Basic block：如果一个点**只有一个前驱和一个后继**，那么这样的node可以与其余的进行合并
- One variable at a time：上面我们是基于整体性的做数据流方程的，但是，对于**大型程序或者复杂的代码**，同时计算所有变量的数据流信息可能会**非常耗时**。因此，当只需要某个变量的数据流信息时，可以单独使用深搜方法计算该变量的信息。

- 数据流方程的**集合**有两个比较好的表示方法，位数组（array of bits）和链表(sorted lists of variables)。位数组是用一位来表示一个元素的状态，并运算需要N/K次操作。链表则是其中的成员是集合的元素，合并的大小和链表的长度有关。假设有N变量，计算机每个字K位，则集合是稀疏的（元素小于N/K），则使用有序表表示，如果是密集的，则使用数组更好
- 数据流算法最坏是O(N^4)，但是实际操作往往在O(N)-O(N ^ 2)之间

### 9.3 最小不动点

- 数据流方程的任何解都是一个近似的保守解（conservative approximation)，即我们会误认为一个变量也是活跃的，哪怕它并不活跃。这使得编译器所使用的寄存器比实际需要的多，但是能保证生成的代码一定是正确的。
- 那么显然，**会有一个最小的解，称为最小不动点**（Least Fixed Points）
- 编译器绝不可能判断一个给定的标号是否可达，所以必须使用保守近似值
- 动态活跃： Avariable a is dynamically live at node n if **some execution of the program** goes from n to a use of a without going through any definition of a.
- 静态活跃：Avariable a is statically live at node n if there is **some path of control-flow edges** from n to some use of a that does not go through a definition of a.
- 动态活跃=>静态活跃，优化编译器根据静态活跃，因为一般计算不出动态活跃信息

```C++
"some execution of the program"关注的是实际运行时的操作和结果，而"some path of control-flow edges"关注的是在静态分析中根据代码结构推断出的可能路径。
  
c = b*b + a
if (c>=a)
  print(1)
else
  print(2)
这里是静态，觉得print(1)和print(2)都有可能执行
但如果是动态，分析执行可能，觉得只会执行print(1)
```



### 9.4 冲突图

- 阻止a和b放入同一个寄存器，使用矩阵或者无向图，实际上是看in集，**in集**里同时出现的就是冲突的

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230520200519637.png" alt="image-20230520200519637" style="zoom:50%;" />



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606123813845.png" alt="image-20230606123813845" style="zoom:30%;" />



- 要避免人为制造冲突。在每个非 move 指令中，对于被定义的变量 a 和此时处于活跃状态的变量 b1,...,bj，在它们之间添加干涉边(a, b1),...,(a, bj)，表示它们之间存在干涉关系。同样地，在每个 move 指令a ← c 中，如果变量c处于活跃状态且不等于bi，则在变量 a 和 bi 之间添加干涉边(a, b1),...,(a, bj)，表示它们之间也存在干涉关系。

### 9.5 习题分析

- Control edge：这里有一个断连，就和trace很像
- 冲突图就是看in集，in集里存在的元素是冲突的

## Part 10 寄存器分配

### 10.1 定义

- 在前一章中，我们最终可以从冲突图看出，哪些变量不能放在同一个寄存器中
- 寄存器分配是编译器中非常重要的一个阶段，用于将程序中的众多临时变量（Temporary Variables）和寄存器（Registers）进行映射，以便程序能够在少量的寄存器中高效地运行。
- 在实现上，可以将MOVE指令的源操作数和目的操作数分配到同一个寄存器中，以便MOVE指令被删除。同时，为了实现寄存器分配，可以采用干涉图染色算法（Interference Graph Coloring Algorithm）

### 10.2 图着色

#### 10.2.1 定义

​	通过将变量的冲突关系表示为图中的边，寄存器分配等价于图着色问题，这是一个np完全问题，包含构造简化溢出选择四部分

- 构造：构造冲突图，node代表变量，edge代表两变量不能同时在一起，可以从两变量是否同时live看
- 简化：把邻居少于寄存器个数K的点去除
- 溢出：**在简化过程中**，发现此时的图只剩下高度数点了，可以把一个变量放入内存中。我们还会**乐观估计**这个点有可能不冲突，先暂时放入栈里，视为**潜在溢出节点**，留待检查。（**潜在的原因是：它的邻居有可能同色，使得该节点也能分配到一种颜色**）
- 选择：从栈顶开始弹出着色，如果potential spill node真的无法分配，就成了实际溢出节点
- 重新开始：由于产生了实际溢出，该点的每次使用都要先从内存中取，放入新的临时变量，因此此时代码被改写，需要重新进行整个流程，一般不超过1-2次。

#### 10.2.2 算法示例

- 启发式算法（K=颜色数量）

- 图中度数小于K的点，可以被去掉，并且入栈记录，不影响图可着色。
- 剩下度数大于K的点，假设它只是潜在溢出点，可以被去掉，也入栈记录。
- 然后栈弹出，任意分配颜色。
- 很明显，如果没有第二步，即所有点度数都小于K，那么一定能着色。
- 有了第二步，出栈时就有可能无法分配颜色，这时候就是一个溢出，需要将变量放到内存以减小它的活跃范围

​    用书上的例子：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522144352612.png" alt="image-20230522144352612" style="zoom:50%;" />

​	得到的结果是：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522144412836.png" alt="image-20230522144412836" style="zoom:50%;" />

### 10.3 合并节点

#### 10.3.1 合并算法

- 合并实际上算一种优化，没有合并也能够分配成功。

- 合并的原因是两个变量有move关系，也就是在某一刻会出现a=b，并且a与b之间没有干涉边（**即不存在，不能放入同一个寄存器的冲突**），那么新节点ab可以合并，其所有边就是a和b之前的边

- 但是很遗憾的是，不能将前面所言的，所有没有冲突的move两端就全部合并，盲目合并可能使得图不可着色，我们采取保守的合并策略，简单说就是，确保这次合并不会影响图着色。

- 怎样保证呢？只要合并后的点是可被简化的，那么它肯定不影响。

- Briggs: a、b合并后的节点ab，它的高度数(>=K条边)的邻节点数量<K。

- George: a的每一个邻居t，要么t与b已有冲突，或者t是低度数节点。

- <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606154414138.png" alt="image-20230606154414138" style="zoom:50%;" />

  

​    举例，也是看先删除了三个点，并且出现了d = c，后面不再使用c

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522144810984.png" alt="image-20230522144810984" style="zoom:50%;" />

​	而，可以进行合并

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522145049656.png" alt="image-20230522145049656" style="zoom:50%;" />

​	能合并的两个点，必须只有一条虚线，如果既虚线也实线就不能合并，必须要做简化。并且，合并与简化的顺序是会影响的，书中规定先简化，并且引入冻结的概念

![image-20230522150207217](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522150207217.png)

#### 10.3.2 溢出的有效处理：

​	课本在这里放了一个小概念，之前我们提到了遇到要放在内存的真溢出节点时候，需要重新开始，但是一种更有效的算法是，如果在发现需要溢出之前已经进行了节点合并，那么这些合并操作将会被保留下来；但是，如果在发现需要溢出之后进行了节点合并，那么这些合并操作将会被丢弃（解除合并）。



### 10.4 预着色节点

**定义**

​	图中会有一些节点，代表的就是真实寄存器，比如rax，六个参数寄存器，callee-save寄存器等，这些在codegen时会被显式使用到，所以不可避免地会出现在图中。它们**不应该被合并，也不能被简化，它们具有特定颜色**。同时， 这些节点的活跃范围必须很小，要是真实寄存器的活跃范围都很大，那么还怎么分配寄存器给临时变量呢，它们一定会有很多冲突。

**分配**

- 活跃范围主要靠move给一个新的临时变量，过程结束再move回来，这样它在这个过程中就是不活跃的。而当这个函数存在较大压力的时，t231会溢出，否则把t231和r7合并。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230606161809975.png" alt="image-20230606161809975" style="zoom:35%;" />

- 对于一个本地变量或编译器临时变量，如果它不跨越任何过程调用，通常应该分配到一个调用者保存寄存器（**caller-save register**），这样就可以避免寄存器的保存和恢复操作。但是，如果一个变量需要跨越多个过程调用，那么就应该将它分配到一个被调用者保存寄存器（**callee-save register**）中，这样只需要在进入和退出被调用过程时保存和恢复该寄存器一次即可。
- 如果一个变量x需要跨越一个过程调用，并且它与一些已经预先分配的调用者保存寄存器发生冲突，或者与一些新创建的临时变量（用于分配被调用者保存寄存器）发生冲突，那么就可能需要将该变量溢出到内存中。进行溢出时，将**会选择一个度数较高但使用较少的节点t231来溢出**，而不是直接溢出变量x。
- 实际上，临时变量和真实寄存器一定会被合并，随后的溢出是源于局部变量的分配，当出现call指令，会再用到真实寄存器，call节点上所有量都是活跃的，这时候局部变量和真实寄存器就会冲突，局部变量还会和临时变量冲突，导致必然出现溢出。由于临时变量度数大，所以会先入栈，反而会得不到颜色，导致真实溢出，最后被替换掉。
- 非callee-save的寄存器活跃范围，需要在call指令的时候，将它们放到call的dst，表示不是跨过程活跃。这样会使得它们与跨过程活跃临时变量冲突，临时变量就会被迫先分配callee-save，如果都不够用，就会溢出。

**例子**

​    在书上提了一个十分好的例子，来说明这里的溢出等，可以看英文的245页

### 10.5 图着色的实现

​	在实操上，需要查询node X的所有邻居（使用adjacency list），以及X和Y是否相邻（二维矩阵）。使用时往往要冗余的同时使用。

### 10.6 习题分析

​	本次习题模拟了一个过程，要理解什么是预溢出（就是假设溢出）+合并有虚线的点（运用两种原则，对比一下简单画图）

## Part 11 垃圾收集

### 11.1 定义

​	该部分运行的部分如图所示：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230605201103370.png" alt="image-20230605201103370" style="zoom:50%;" />

​	**指针链无法到达**的记录称之为垃圾，需要进行垃圾收集，使得那部分空间可以重新使用，这不是由编译器而是由运行时的系统完成的。

​	我们需要采用一种保守的方法，保证活跃记录都是可到达的，并尽可能减少那些可到达但非活跃的记录数量

### 11.2 算法

​	首先给出书中示例，实际上是一个环+一棵树

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200129997.png" alt="image-20230522200129997" style="zoom:50%;" />

#### 11.2.1 Mark-and-sweep garbage collection

​	中文描述：对**所有的根节点**，做一遍深搜，搜到的节点就标记一下。然后对堆内所有节点做判断，把所有标记过的节点去除标记，留待下次垃圾回收时用；对所有未标记节点，链接到一起成为一个freelist。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200219456.png" alt="image-20230522200219456" style="zoom:50%;" />

​	而其中的DFS算法则如下：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200244263.png" alt="image-20230522200244263" style="zoom:50%;" />

​	**垃圾收集的代价**：大小为H的堆中有R个字可达数据，一次垃圾收集的代价是c1R+c2H，c1c2为常数，例如c1是10条指令，c2是3条指令，得到的好处是H-R的空间，而分摊代价为：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200558515.png" alt="image-20230522200558515" style="zoom:50%;" />

​	R接近H，代价极大；否则的话，H远大于R，代价接近c2；如果R/H>ratio，就要申请更多空间



#### 11.2.2 优化

​	上面的方法会碰到爆栈的问题，因此使用如下的手工栈是一个好选择，这里其实就是手动模拟了入栈和出栈，用t来控制：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200725931.png" alt="image-20230522200725931" style="zoom:50%;" />

​	当然，这样还是用了太多空间，还有更节省空间的方法，利用指针反转，这里家作题有详细练习，核心思想是在寻址的过程中，把存子的变为了存父的，回溯时，又重新变为存子的。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522200821004.png" alt="image-20230522200821004" style="zoom:50%;" />

#### 11.2.3 Reference Counts

​	在这个机制中，每个记录都包含一个引用计数，用于记录有多少指针指向它。每当一个指针（例如指针x.fi）被赋值给记录中的一个字段，就会对指针(x.fi)所指向的原记录和现记录修改：指向新记录的引用计数将加一，而原来指向的记录（如 [x.fi](http://x.fi/) 原来指向的记录）的引用计数将减一。

​	通过这种方式，程序可以跟踪每个记录有多少指针在引用它，以判断何时可以安全地释放该记录所占用的内存资源。当某个记录的引用计数降至零时，说明没有任何指针再指向该记录，可以将该记录放入空闲链表（Free List）中以供后续的内存分配使用。同时，也需要将该记录所指向的所有记录的引用计数减一，以确保内存资源能够被正确地回收和重复利用。

​	但是有一些问题：

- 无法回收环构成的垃圾（可以用使用数据结构解环、计数与标记清扫相结合的方法缓解）
- 需要更大的代价

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522201807412.png" alt="image-20230522201807412" style="zoom:50%;" />

​	为了解决环的问题，有两个方案：

- 第一种是靠程序员
- 第二种是和前面的方法结合起来，定期的去判断是否有环然后做垃圾回收。

#### 11.2.4 Copying Collection

​		其思路是解决碎片的问题，把分散的=>紧凑的，比如下面，从分散的变成了紧凑的

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522202745844.png" alt="image-20230522202745844" style="zoom:30%;" />

​		当需要回收垃圾时，垃圾回收器会首先将指针 `next` 初始化为指向到空间（To-Space）的开始位置。然后对于从空间（From-Space）中每个可达（Reachable）的记录，都会将其复制到到空间的位置 `next`，并将 `next` 的值增加该记录所占用的空间大小。这样，所有从空间中可达的记录都将得到复制，并存储到到空间中。

​	之后是转发（Forwarding）操作。由于在复制过程中，每个从空间中的记录都被复制到了到空间中，因此原先指向从空间中记录的指针也需要修改，使其指向对应的到空间中的记录。在转发操作中，给定一个指针 `p`，如果它指向了从空间中的记录，则需要将它转发到对应的到空间中的记录。具体来说，转发操作的实现可以分为以下三种情况：

1. 如果指针 `p` 已经指向了到空间中的记录，则直接返回其指向的地址。
2. 如果指针 `p` 指向了from-space中的记录，并且记录已经被复制到了to-space中，则将指针 `p` 的字段 `f1` 修改为指向到空间中对应的记录，并返回 `p.f1`。
3. 如果指针 `p` 指向了从空间中的记录，但是记录还没有被复制到到空间中，则需要先将该记录复制到到空间的位置 `next`，然后将指针 `p` 的字段 `f1` 修改为指向到空间中的记录。最后更新 `next` 的值，使其指向下一个可用的位置。（**就是要指的，一定要先在to space里面**）

​    Forwarding的算法流程如下：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522203615733.png" alt="image-20230522203615733" style="zoom:50%;" />

​	**Cheney's algorithm**：使用BFS的方法，在 Cheney 算法中，垃圾回收器首先将指针 `scan` 和 `next` 初始化为指向到空间（To-Space）的开始位置。然后对于每个程序变量（Root） `r`，都需要通过转发操作将其指向的对象修改为对应的到空间中的记录。这样可以确保从空间中所有可达的记录都会被复制到到空间中，并得到有效对象的转发。

​	接下来是 Cheney 算法的核心部分。通过使用**广度优先搜索（这样是由浅层往深层括，可以一定程度上避免问题）**，垃圾回收器可以按顺序遍历到空间中所有可达的记录，并将其复制到新的位置。具体来说，对于到空间中每个位置 `scan`，都需要遍历该位置上记录的所有字段，并将这些字段指向的对象进行转发。遍历完所有字段后，将 `scan` 的值增加该记录所占用的空间大小，以便继续遍历下一个可达的位置。如此往复，直到遍历完了所有可达的记录为止。

​	通过 Cheney 算法，垃圾回收器可以高效地遍历堆中所有可达的对象，并将有效对象复制到到空间中，以实现内存回收和内存空间的整理。这种算法在一些现代的垃圾回收器中得到了广泛应用。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230522203929157.png" alt="image-20230522203929157" style="zoom:50%;" />

## Part 12 历年卷回顾

​	由于进行了大范围课改，导致历年卷的很多概念现在是没有重合上的，那么只能通过大题简单回顾一下了（谁知道考试会不会超纲？）

### 12.1 2021-2022学年

#### 12.1.1 大题1

​	"declaration before use" 和 "most closely nested rule for block structure" 都是编程中的两个重要原则。

​	首先，"declaration before use" 指的是在程序中必须先声明一个变量或函数，然后才能使用它。换句话说，在使用一个变量或函数之前，必须先在代码中进行相应的声明。这个原则适用于大多数编程语言，包括C、C++、Java等。

​	例如，在C语言中，我们需要先声明变量，然后再使用它：

```C++
int x;  // 声明变量x

x = 5;  // 使用变量x，赋值为5
```

​	如果我们没有先声明变量x，而直接使用它，则会导致编译错误。

​	而 "most closely nested rule for block structure" 是指在一个程序中，如果多个同名变量被定义在嵌套的作用域或代码块中，那么最内层的作用域或代码块中的变量将覆盖外层作用域或代码块中的同名变量。也就是说，在嵌套的作用域中，最近的那个变量声明将起作用。

​	例如，考虑以下代码片段：

```C++
int x = 10;

if (x > 5) {
    int x = 5;
    printf("%d", x);  // 输出5，使用最近的x变量
}

printf("%d", x);  // 输出10，使用外层的x变量
```

​	在这个例子中，我们在外层作用域中声明了一个变量x，并赋值为10。然后，在if语句的代码块中，我们又声明了一个同名的变量x，并赋值为5。当我们在if语句的代码块中打印变量x时，输出的是最近的内层变量x的值，即5。而在if语句之外的代码中打印变量x时，输出的是外层的变量x的值，即10。

​	这两个原则都是为了确保程序的变量和函数在使用之前已经被正确声明，并且在作用域之间能够正确地处理同名的变量。

#### 12.1.2 大题2

​	**四元式形式的三地址码**

​	定义：三地址码用来表示算术表达式求值，形如 `x = y op z`。对于三地址码，保存其信息需要 3 个地址以及 1 个操作符。因此我们用 **四元式 quadruple** 的方式来存储三地址码。例如下面的经典

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616204153013.png" alt="image-20230616204153013" style="zoom:50%;" />

​	以及对应的四元式，其中_表示空：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616204215770.png" alt="image-20230616204215770" style="zoom:50%;" />

​	三地址码另一个不同的实现是用自己的指令来代表临时变量，这样地址域从 3 个减少到了 2 个，目标地址总是一个临时变量，用行号表示。这种实现方式称为 **三元式 triple**。前述三地址码用三元式表示就是(if_f是如果错)：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616204316842.png" alt="image-20230616204316842" style="zoom:50%;" />

```C++
i = 0;
while(i < 5){
    if(i < 3) then{
        x = i*2;
    }else{
        x = i*3;
    }
    i = i+1;
}

自拟答案：
(0)(asn,0,i)
(1)(lt,5,i)
(2)(if_f,(1),(11))
(3)(lt,i,3)
(4)(if_f,(3),(7))
(5)(mul,i,2)
(6)(asn,x,(5))
(7)(mul,i,3)
(8)(asn,x,(7))
(9)(add,i,1)
(10)(asn,i,(9))
(11)(halt,_,_)

```

#### 12.1.3 大题3

​	感觉完全没见过==

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616210506563.png" alt="image-20230616210506563" style="zoom:50%;" />

### 12.2 2020-2021学年

#### 12.2.1 大题1

（1）写出计算类型的属性文法；

（2）画出 `x,y,z: int` 的依赖图。

```
decl -> varlist : type
varlist -> varlist, id | id
type -> int
```

​	参考复习：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616211751498.png" alt="image-20230616211751498" style="zoom:50%;" />

和

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616211748260.png" alt="image-20230616211748260" style="zoom:50%;" />

#### 12.2.2 大题2

给出下面代码的分隔符号表，每个作用域在不同的表里（任意挑一个作用域写，保证是三层表即可）。

```c++
int i, j;
int f(int size) {
    char l, tmp;
    {
        double j;
        ...
    }
        ...
    {
        char* j;
        ...
    }
}
```

参考知识：

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616211938053.png" alt="image-20230616211938053" style="zoom:50%;" />

#### 12.2.3 大题3

写出下列代码的 pcode。

```C++
if (true)
while (true)
{
  if (false) {
        break;
  }
    else {
        other;
    }
}
```

​	p-code定义：也就是有一个栈，不断弹出和运算，更多的调用看xyx笔记-**感觉基本没提到今年**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230616212141460.png" alt="image-20230616212141460" style="zoom:50%;" />

#### 12.2.4 大题4

（1）解释 pass-by-value-result 和 pass-by-reference 的区别（2）给出下列代码在 pass-by-value-result 与 pass-by-reference 时的输出。

```
int f(int x, int y) {
    y = 5;
    x++;
}

main() {
    int a=1;
    f(a, a);
    printf("%d", a);
}
```

参考：xyx笔记

#### 12.2.5 大题5

（1）解释 align a; 的作用（2）如果 MEMSIZE 为 8096，求程序的堆内存大小（3）这种内存管理方法堆中是否有碎片？

```
typedef double align;
typedef union header
{
    struct {
        union header* t;
        unsigned aa;
        unsigned bb;
    }
    align a;
} header;
static header mem[MEMSIZE];
static header* memptr = NULL;
```